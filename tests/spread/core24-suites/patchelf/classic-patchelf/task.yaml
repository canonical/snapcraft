summary: Build a classic snap and validates elf patching

prepare: |
  #shellcheck source=tests/spread/tools/snapcraft-yaml.sh
  . "$TOOLS_DIR/snapcraft-yaml.sh"
  # set_base snap/snapcraft.yaml

  apt-get install patchelf dpkg-dev -y
  apt-mark auto patchelf dpkg-dev

restore: |
  snapcraft clean --destructive-mode
  rm -f ./*.snap
  apt remove libpng16-16t64 -y

execute: |
  snapcraft pack --destructive-mode

  arch_triplet="$(dpkg-architecture -q DEB_HOST_MULTIARCH)"

  # Account for /usr merge.
  RPATH_MATCH="^/snap/core24/current/lib/$arch_triplet"
  RPATH_ORIGIN_MATCH="^\\\$ORIGIN/../fake-lib:/snap/core24/current/lib/$arch_triplet"

  # Verify typical binary.
  patchelf --print-interpreter prime/bin/hello-classic | MATCH "^/snap/core24/current/lib.*ld.*.so.*"
  patchelf --print-rpath prime/bin/hello-classic | MATCH "${RPATH_MATCH}"

  # Verify binary w/ existing rpath.
  patchelf --print-interpreter prime/bin/hello-classic-existing-rpath | MATCH "^/snap/core24/current/lib.*ld.*.so.*"
  patchelf --print-rpath prime/bin/hello-classic-existing-rpath | MATCH "${RPATH_ORIGIN_MATCH}"

  # Verify untouched no-patchelf.
  patchelf --print-interpreter prime/bin/hello-classic-no-patchelf | MATCH "^/lib.*ld.*.so.*"
  rpath="$(patchelf --print-rpath prime/bin/hello-classic-no-patchelf)"
  if [[ -n "${rpath}" ]]; then
     echo "found rpath with no-patchelf: ${rpath}"
     exit 1
  fi

  # ensure system libraries are not loaded
  snap install classic-patchelf_0.1_amd64.snap --dangerous --classic
  classic-patchelf
  apt install libpng16-16t64 -y
  classic-patchelf

  # debugging - fail to see the test output
  exit 1
